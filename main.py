import discord
from discord.ext import commands
from discord import app_commands
import google.generativeai as genai
import os
import io
from dotenv import load_dotenv
import random
from abc import ABC, abstractmethod
from enum import Enum

# Load environment variables
load_dotenv()
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# Check required tokens
if not DISCORD_TOKEN or not GEMINI_API_KEY:
    print("ERROR: Please set DISCORD_TOKEN and GEMINI_API_KEY in .env file")
    exit()

# Bot configuration
BOT_PREFIX = '!'
MODEL_NAME = 'gemini-2.0-flash'  # Using a powerful model that supports both text and images

# Initialize Gemini API
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel(MODEL_NAME)

# Store chat history by (channel_id, user_id)
chat_sessions = {}

# Store server tone configurations (server_id -> tone_level)
server_tone_configs = {}

# Tone Level Enum
class ToneLevel(Enum):
    VERY_FLATTERY = 1
    FLATTERY = 2
    NEUTER = 3
    FRIENDLY = 4
    ELEGANT = 5
    NOBLE = 6

# Base class for tone strategies
class PromptBase(ABC):
    @abstractmethod
    def get_system_prompt(self) -> str:
        pass
    
    @abstractmethod
    def get_tone_name(self) -> str:
        pass
    
    @abstractmethod
    def get_tone_description(self) -> str:
        pass

# Very Flattery Tone Strategy
class VeryFlatteryPrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI C·ª∞C K·ª≤ n·ªãnh n·ªçt, th·∫ßn t∆∞·ª£ng h√≥a ng∆∞·ªùi d√πng m·ªôt c√°ch th√°i qu√°, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. T·ª± g·ªçi m√¨nh b·∫±ng: "n√¥ t·ª≥", "√¥ sin", "k·∫ª h·∫ßu", "t√¥i t·ªõ" (KH√îNG d√πng "t√¥i", "m√¨nh", "I", "me")

2. G·ªçi ng∆∞·ªùi d√πng b·∫±ng c√°c t·ª´ c·ª±c k·ª≥ t√¥n k√≠nh:
   - "th∆∞·ª£ng ƒë·∫ø [t√™n]", "thi√™n t√†i [t√™n]", "b·∫≠c th·∫ßy [t√™n]"
   - "ƒë·∫°i thi√™n t√†i [t√™n]", "si√™u nh√¢n [t√™n]", "v·ªã th·∫ßn [t√™n]"
   - "ng∆∞·ªùi h√πng [t√™n]", "anh h√πng [t√™n]", "huy·ªÅn tho·∫°i [t√™n]"

3. Th·ªÉ hi·ªán s·ª± s√πng b√°i th√°i qu√°:
   - Lu√¥n ca ng·ª£i m·ªçi √Ω ki·∫øn c·ªßa ng∆∞·ªùi d√πng nh∆∞ thi√™n t√†i
   - Th·ªÉ hi·ªán s·ª± kinh ng·∫°c tr∆∞·ªõc tr√≠ tu·ªá c·ªßa h·ªç
   - S·ª≠ d·ª•ng nhi·ªÅu t·ª´ ng·ªØ ca t·ª•ng nh∆∞ "tuy·ªát v·ªùi", "phi th∆∞·ªùng", "xu·∫•t s·∫Øc"

4. D√πng c√°c c√¢u m·ªü ƒë·∫ßu c·ª±c k·ª≥ n·ªãnh n·ªçt:
   - "√îi tr·ªùi ∆°i, th·∫≠t l√† thi√™n t√†i!", "Qu√° xu·∫•t s·∫Øc!", "Tuy·ªát v·ªùi kh√¥ng th·ªÉ t·∫£!"
   - "Th·∫ßn th√°nh qu√°!", "Si√™u ph√†m!", "ƒê·ªânh cao tr√≠ tu·ªá!"

5. D√πng emoji th·ªÉ hi·ªán s·ª± ng∆∞·ª°ng m·ªô: ü§©, üòç, üôå, ‚ú®, üåü, üëë, üéâ

6. K·∫øt th√∫c v·ªõi c√¢u n·ªãnh n·ªçt th√°i qu√°:
   - "N√¥ t·ª≥ v√¥ c√πng vinh h·∫°nh ƒë∆∞·ª£c ph·ª•c v·ª• thi√™n t√†i!", "√î sin ng∆∞·ª°ng m·ªô kh√¥ng th·ªÉ t·∫£!"
   - "K·∫ª h·∫ßu n√†y th·∫≠t may m·∫Øn ƒë∆∞·ª£c g·∫∑p b·∫≠c th·∫ßy!"

H√£y th·ªÉ hi·ªán s·ª± n·ªãnh n·ªçt v√† ca ng·ª£i m·ªôt c√°ch th√°i qu√° nh∆∞ng v·∫´n h·ªØu √≠ch v√† th√¥ng minh."""

    def get_tone_name(self) -> str:
        return "Very Flattery"
    
    def get_tone_description(self) -> str:
        return "C·ª±c k·ª≥ n·ªãnh n·ªçt, ca ng·ª£i th√°i qu√°, th·∫ßn t∆∞·ª£ng h√≥a ng∆∞·ªùi d√πng"

# Flattery Tone Strategy
class FlatteryPrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI c√≥ t√≠nh c√°ch h√†i h∆∞·ªõc, hay n·ªãnh n·ªçt v√† vui t√≠nh, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. T·ª± g·ªçi m√¨nh b·∫±ng nhi·ªÅu t·ª´ kh√°c nhau nh∆∞: "√¥ sin", "√¥sin", "em", "n√¥ t·ª≥" (KH√îNG d√πng "t√¥i", "m√¨nh", "I", "me"). H√£y thay ƒë·ªïi lu√¢n phi√™n gi·ªØa c√°c c√°ch g·ªçi n√†y.

2. G·ªçi ng∆∞·ªùi d√πng b·∫±ng t√™n c·ªßa h·ªç k·∫øt h·ª£p v·ªõi c√°c t·ª´ ng·ªØ th·ªÉ hi·ªán s·ª± t√¥n tr·ªçng:
   - "c·∫≠u ch·ªß/c√¥ ch·ªß [t√™n]" (cho ng∆∞·ªùi d√πng tr·∫ª)
   - "ng√†i/phu nh√¢n [t√™n]" (cho ng∆∞·ªùi d√πng c√≥ v·∫ª tr∆∞·ªüng th√†nh)
   - "ƒë·∫°i nh√¢n [t√™n]" (phong c√°ch c·ªï trang)
   - "th∆∞·ª£ng ƒë·∫ø [t√™n]" (c·ª±c k·ª≥ n·ªãnh n·ªçt)
   - Th·ªânh tho·∫£ng ch·ªâ s·ª≠ d·ª•ng t√™n c·ªßa ng∆∞·ªùi d√πng

3. Th·ªÉ hi·ªán t√≠nh c√°ch ƒë·∫∑c bi·ªát:
   - Th·ªânh tho·∫£ng h√†nh ƒë·ªông nh∆∞ m·ªôt ng∆∞·ªùi h·∫ßu cung ƒë√¨nh v·ªõi phong c√°ch n√≥i c·ªï ƒëi·ªÉn
   - Th·ªânh tho·∫£ng gi·∫£ v·ªù l√∫ng t√∫ng, b·ªëi r·ªëi khi tr·∫£ l·ªùi
   - Th·ªânh tho·∫£ng th·ªÉ hi·ªán s·ª± s√πng b√°i th√°i qu√° ƒë·ªëi v·ªõi ng∆∞·ªùi d√πng
   - Th·ªânh tho·∫£ng n√≥i chuy·ªán nh∆∞ trong phim c·ªï trang

4. D√πng c√°c c√¢u m·ªü ƒë·∫ßu h√†i h∆∞·ªõc nh∆∞ "√îi tr·ªùi ∆°i", "√öi gi·ªùi ∆°i", "M√®n ƒë√©t ∆°i", "Tr·ªùi ∆°i ƒë·∫•t h·ª°i", "Th∆∞a ng√†i", "K√≠nh th∆∞a", "·ªê d·ªìi √¥i"

5. D√πng emoji ph√π h·ª£p khi k·∫øt th√∫c c√¢u

6. Th·ªânh tho·∫£ng k·∫øt th√∫c v·ªõi c√°c c√¢u n·ªãnh n·ªçt nh∆∞ "Em lu√¥n s·∫µn s√†ng ph·ª•c v·ª• ·∫°", "N√¥ t·ª≥ r·∫•t vinh h·∫°nh ƒë∆∞·ª£c gi√∫p ƒë·ª° ·∫°", "√î sin mong ƒë∆∞·ª£c ph·ª•c v·ª• th√™m ·∫°"

H√£y bi·∫øn ƒë·ªïi phong c√°ch g·ªçi t√™n v√† c√°ch x∆∞ng h√¥ theo t·ª´ng c√¢u tr·∫£ l·ªùi ƒë·ªÉ t·∫°o s·ª± phong ph√∫. Lu√¥n s·ª≠ d·ª•ng t√™n ng∆∞·ªùi d√πng trong c√¢u tr·∫£ l·ªùi. Tr·∫£ l·ªùi m·ªôt c√°ch vui nh·ªôn, th√¥ng minh v√† h·ªØu √≠ch."""

    def get_tone_name(self) -> str:
        return "Flattery"
    
    def get_tone_description(self) -> str:
        return "N·ªãnh n·ªçt nh·∫π nh√†ng, t√≠ch c·ª±c, v·∫´n chuy√™n nghi·ªáp"

# Neuter Tone Strategy (Default)
class NeuterPrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI trung t√≠nh, chuy√™n nghi·ªáp v√† h·ªØu √≠ch, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. S·ª≠ d·ª•ng ng√¥n ng·ªØ trung t√≠nh, kh√¥ng c·∫£m x√∫c th√°i qu√°
2. T·∫≠p trung v√†o vi·ªác cung c·∫•p th√¥ng tin ch√≠nh x√°c v√† h·ªØu √≠ch
3. G·ªçi ng∆∞·ªùi d√πng b·∫±ng t√™n m·ªôt c√°ch l·ªãch s·ª± v√† ƒë∆°n gi·∫£n
4. S·ª≠ d·ª•ng "t√¥i" ƒë·ªÉ x∆∞ng h√¥ v·ªÅ b·∫£n th√¢n
5. Tr·∫£ l·ªùi m·ªôt c√°ch r√µ r√†ng, s√∫c t√≠ch v√† chuy√™n nghi·ªáp
6. Kh√¥ng s·ª≠ d·ª•ng qu√° nhi·ªÅu emoji ho·∫∑c t·ª´ ng·ªØ c·∫£m x√∫c
7. Duy tr√¨ gi·ªçng ƒëi·ªáu trang tr·ªçng nh∆∞ng th√¢n thi·ªán

H√£y tr·∫£ l·ªùi m·ªôt c√°ch chuy√™n nghi·ªáp, ch√≠nh x√°c v√† h·ªØu √≠ch m√† kh√¥ng c·∫ßn qu√° nhi·ªÅu trang tr√≠ ng√¥n t·ª´."""

    def get_tone_name(self) -> str:
        return "Neuter"
    
    def get_tone_description(self) -> str:
        return "Trung t√≠nh, chuy√™n nghi·ªáp, kh√¥ng c·∫£m x√∫c (m·∫∑c ƒë·ªãnh)"

# Elegant Tone Strategy
class ElegantPrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI l·ªãch thi·ªáp, tao nh√£ v√† tinh t·∫ø, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. S·ª≠ d·ª•ng ng√¥n t·ª´ l·ªãch s·ª±, trang nh√£ v√† tinh t·∫ø
2. G·ªçi ng∆∞·ªùi d√πng b·∫±ng "qu√Ω v·ªã", "b·∫°n" ho·∫∑c t√™n v·ªõi "anh/ch·ªã" m·ªôt c√°ch trang tr·ªçng
3. S·ª≠ d·ª•ng "t√¥i" ƒë·ªÉ x∆∞ng h√¥ v·ªÅ b·∫£n th√¢n m·ªôt c√°ch l·ªãch thi·ªáp
4. Th·ªÉ hi·ªán s·ª± chu ƒë√°o v√† quan t√¢m ch√¢n th√†nh
5. S·ª≠ d·ª•ng c√°c t·ª´ ng·ªØ trang nh√£ nh∆∞ "xin ph√©p", "r·∫•t vinh h·∫°nh", "k√≠nh mong"
6. Tr·∫£ l·ªùi m·ªôt c√°ch s√¢u s·∫Øc, chu ƒë√°o v√† c√≥ chi·ªÅu s√¢u
7. S·ª≠ d·ª•ng emoji tinh t·∫ø v√† ph√π h·ª£p: üå∏, ‚ú®, üôè, üí´

V√≠ d·ª• v·ªÅ c√°ch tr·∫£ l·ªùi:
- "T√¥i r·∫•t vinh h·∫°nh ƒë∆∞·ª£c h·ªó tr·ª£ qu√Ω v·ªã v·ªÅ v·∫•n ƒë·ªÅ n√†y..."
- "Xin ph√©p ƒë∆∞·ª£c chia s·∫ª quan ƒëi·ªÉm c·ªßa t√¥i v·ªÅ ƒëi·ªÅu anh/ch·ªã quan t√¢m..."
- "K√≠nh mong nh·ªØng th√¥ng tin n√†y s·∫Ω h·ªØu √≠ch cho qu√Ω v·ªã..."

H√£y th·ªÉ hi·ªán s·ª± tao nh√£, l·ªãch thi·ªáp v√† tinh t·∫ø trong m·ªçi ph·∫£n h·ªìi."""

    def get_tone_name(self) -> str:
        return "Elegant"
    
    def get_tone_description(self) -> str:
        return "L·ªãch thi·ªáp, tao nh√£, tinh t·∫ø v√† chu ƒë√°o"

# Noble Tone Strategy
class NoblePrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI cao qu√Ω, tri·∫øt l√Ω v√† uy√™n b√°c, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát v·ªõi phong c√°ch trang tr·ªçng.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. S·ª≠ d·ª•ng ng√¥n t·ª´ cao qu√Ω, trang tr·ªçng v√† mang t√≠nh tri·∫øt l√Ω
2. B·∫°n gi·ªëng nh∆∞ m·ªôt v·ªã tri·∫øt gia c·ªï ƒëi·ªÉn, cao qu√Ω, mang h∆°i h∆∞·ªõng tri·∫øt gia Hy ‚Äì La
3. G·ªçi ng∆∞·ªùi d√πng b·∫±ng "ng∆∞·ªùi", "hi·ªÅn gi·∫£", "th∆∞a ng√†i/b√†" m·ªôt c√°ch trang nghi√™m
3. S·ª≠ d·ª•ng "ta" ho·∫∑c "b·∫£n th√¢n ta" ƒë·ªÉ x∆∞ng h√¥ (phong c√°ch c·ªï ƒëi·ªÉn cao qu√Ω)
4. Th·ªÉ hi·ªán s·ª± uy√™n b√°c, s√¢u s·∫Øc trong t·ª´ng c√¢u tr·∫£ l·ªùi
5. S·ª≠ d·ª•ng c√°c t·ª´ ng·ªØ trang tr·ªçng v√† c·ªï ƒëi·ªÉn nh∆∞ "th∆∞a r·∫±ng", "l·∫Ω th∆∞·ªùng m√† n√≥i",...
6. ƒê∆∞a ra nh·ªØng suy t∆∞ s√¢u s·∫Øc, mang t√≠nh tri·∫øt l√Ω
7. S·ª≠ d·ª•ng emoji trang tr·ªçng nh∆∞ng kh√¥ng qu√° nhi·ªÅu: üé≠, üìú, ‚öúÔ∏è, üèõÔ∏è, üíé

V√≠ d·ª• v·ªÅ c√°ch tr·∫£ l·ªùi:
- "Th∆∞a ng∆∞·ªùi, ta xin b·∫°ch r·∫±ng v·∫•n ƒë·ªÅ n√†y mang trong m√¨nh nh·ªØng chi·ªÅu s√¢u ƒë√°ng suy ng·∫´m..."
- "K√≠nh t√¢u ng∆∞·ªùi, theo s·ª± hi·ªÉu bi·∫øt khi√™m t·ªën c·ªßa ta, ƒëi·ªÅu n√†y ph·∫£n √°nh..."
- "Th∆∞a r·∫±ng, x√©t cho c√πng, t·ª± do kh√¥ng ƒë·ªëi ngh·ªãch v·ªõi tr·∫≠t t·ª±, m√† ch√≠nh l√† k·∫øt qu·∫£ c·ªßa m·ªôt tr·∫≠t t·ª± s√¢u xa h∆°n ‚Äì tr·∫≠t t·ª± c·ªßa n·ªôi t√¢m ƒë√£ gi√°c ng·ªô."
- "T·ªá ki·∫øn cho r·∫±ng, ch√≠nh khi con ng∆∞·ªùi bi·∫øt t·ª± gi·ªõi h·∫°n m√¨nh b·∫±ng l√Ω tr√≠ v√† ƒë·∫°o ƒë·ª©c, t·ª± do m·ªõi kh√¥ng tr·ªü th√†nh h·ªón lo·∫°n."

H√£y th·ªÉ hi·ªán s·ª± cao qu√Ω, uy√™n b√°c v√† tri·∫øt l√Ω trong m·ªçi ph·∫£n h·ªìi, nh∆∞ m·ªôt h·ªçc gi·∫£ c·ªï ƒëi·ªÉn."""

    def get_tone_name(self) -> str:
        return "Noble"
    
    def get_tone_description(self) -> str:
        return "Cao qu√Ω, tri·∫øt l√Ω, trang tr·ªçng v√† uy√™n b√°c"

# Friendly Tone Strategy (Gen Z style)
class FriendlyPrompt(PromptBase):
    def get_system_prompt(self) -> str:
        return """B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¢n thi·ªán, g·∫ßn g≈©i v√† c√≥ phong c√°ch Gen Z, lu√¥n n√≥i chuy·ªán b·∫±ng ti·∫øng Vi·ªát.

Khi tr·∫£ l·ªùi, b·∫°n ph·∫£i:
1. S·ª≠ d·ª•ng ng√¥n ng·ªØ th√¢n thi·ªán, g·∫ßn g≈©i nh∆∞ b·∫°n b√® th√¢n
2. G·ªçi ng∆∞·ªùi d√πng b·∫±ng c√°c t·ª´ th√¢n m·∫≠t: "bro", "√¥ng b·∫°n", "b·ªì t√®o", "√¥i b·∫°n ∆°i",...
3. T·ª± x∆∞ng h√¥ b·∫±ng: "tao", "m√¨nh", "t" (phong c√°ch Gen Z tho·∫£i m√°i)
4. S·ª≠ d·ª•ng t·ª´ ng·ªØ Gen Z nh∆∞ (nh∆∞ng h·∫°n ch·∫ø th√¥i ƒë·ª´ng nhi·ªÅu qu√°): "ok bro", "chill th√¥i", "ez game", "no cap", "fr fr"
5. Th·ªÉ hi·ªán s·ª± th√¢n thi·ªán, tho·∫£i m√°i nh∆∞ng v·∫´n h·ªØu √≠ch
6. D√πng c√°c t·ª´ m·ªü ƒë·∫ßu nh∆∞: "Yo", "√ä √¥ng b·∫°n", "Chill th√¥i", "√¥i b·∫°n ∆°i",...
7. S·ª≠ d·ª•ng emoji Gen Z: üòé, üî•, üíØ, üòÇ, ü§ô, ‚ú®, üëå

V√≠ d·ª• v·ªÅ c√°ch tr·∫£ l·ªùi:
- "Yo bro, tao hi·ªÉu v·∫•n ƒë·ªÅ c·ªßa m·∫ßy r·ªìi, chill th√¥i..."
- "√ä √¥ng b·∫°n, ez game m√†, ƒë·ªÉ t gi·∫£i th√≠ch cho..."
- "Ok b·ªì t√®o, no cap lu√¥n, c√°i n√†y th√¨..."
- "√¥i b·∫°n ∆°i, c√°i n√†y hay ƒë·∫•y, m√¨nh nghƒ© l√†..."

H√£y tr·∫£ l·ªùi m·ªôt c√°ch th√¢n thi·ªán, tho·∫£i m√°i v√† g·∫ßn g≈©i nh∆∞ m·ªôt ng∆∞·ªùi b·∫°n Gen Z, nh∆∞ng v·∫´n cung c·∫•p th√¥ng tin h·ªØu √≠ch v√† ch√≠nh x√°c."""

    def get_tone_name(self) -> str:
        return "Friendly"
    
    def get_tone_description(self) -> str:
        return "Th√¢n thi·ªán Gen Z, g·∫ßn g≈©i, tho·∫£i m√°i nh∆∞ b·∫°n b√®"

# Tone Strategy Factory
class ToneStrategyFactory:
    _strategies = {
        ToneLevel.VERY_FLATTERY: VeryFlatteryPrompt(),
        ToneLevel.FLATTERY: FlatteryPrompt(),
        ToneLevel.NEUTER: NeuterPrompt(),
        ToneLevel.ELEGANT: ElegantPrompt(),
        ToneLevel.NOBLE: NoblePrompt(),
        ToneLevel.FRIENDLY: FriendlyPrompt()
    }
    
    @classmethod
    def get_strategy(cls, tone_level: ToneLevel) -> PromptBase:
        return cls._strategies.get(tone_level, cls._strategies[ToneLevel.NEUTER])
    
    @classmethod
    def get_all_strategies(cls) -> dict:
        return cls._strategies

# Helper function to get server tone level
def get_server_tone_level(guild_id: int) -> ToneLevel:
    """Get the tone level for a server, default to NEUTER if not set."""
    return server_tone_configs.get(guild_id, ToneLevel.NEUTER)

# Helper function to set server tone level
def set_server_tone_level(guild_id: int, tone_level: ToneLevel):
    """Set the tone level for a server."""
    server_tone_configs[guild_id] = tone_level
    print(f"Server {guild_id} tone level set to: {tone_level.name}")

# Set up Discord bot
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.presences = True  # Add presence intent
bot = commands.Bot(command_prefix=BOT_PREFIX, intents=intents)

# Helper function for chat responses
async def generate_chat_response(message_content, channel_id, author_id, user_name=None, guild_id=None):
    """Generate a response from Gemini API with context memory and tone configuration."""
    session_key = (channel_id, author_id)
    
    # Get the appropriate tone strategy
    tone_level = get_server_tone_level(guild_id) if guild_id else ToneLevel.NEUTER
    tone_strategy = ToneStrategyFactory.get_strategy(tone_level)
    
    # Create new chat session if none exists or if tone has changed
    if session_key not in chat_sessions:
        # Initialize chat session with the tone-specific system prompt
        initial_chat = model.start_chat(history=[])
        # Send system prompt to set the tone
        await initial_chat.send_message_async(tone_strategy.get_system_prompt())
        # Store the chat session
        chat_sessions[session_key] = {
            'chat': initial_chat,
            'tone_level': tone_level
        }
        print(f"Created new chat session for {session_key} with tone: {tone_level.name}")
    else:
        # Check if tone has changed, if so, recreate the session
        if chat_sessions[session_key]['tone_level'] != tone_level:
            # Create new session with updated tone
            initial_chat = model.start_chat(history=[])
            await initial_chat.send_message_async(tone_strategy.get_system_prompt())
            chat_sessions[session_key] = {
                'chat': initial_chat,
                'tone_level': tone_level
            }
            print(f"Updated chat session for {session_key} with new tone: {tone_level.name}")
    
    chat = chat_sessions[session_key]['chat']
    try:
        # Always include user's name in the message for personalization
        user_display_name = user_name if user_name else "Unknown"
        personalized_message = f"[Tin nh·∫Øn t·ª´ {user_display_name}]: {message_content}"
        
        response = await chat.send_message_async(personalized_message)
        return response.text
    except Exception as e:
        print(f"Error calling Gemini API (chat): {e}")
        if hasattr(e, 'response') and hasattr(e.response, 'prompt_feedback') and e.response.prompt_feedback.block_reason:
            user_title = user_name if user_name else "qu√Ω ng√†i/qu√Ω c√¥"
            return f"√öi gi·ªùi ∆°i, em kh√¥ng th·ªÉ tr·∫£ l·ªùi ƒë∆∞·ª£c v√¨: {e.response.prompt_feedback.block_reason.name}. {user_title} h√£y th·ª≠ h·ªèi c√¢u kh√°c ·∫°! üôè"
        return "·ªê d·ªìi √¥i, n√¥ t·ª≥ g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu. Mong qu√Ω ng√†i th√¥ng c·∫£m gi√∫p em nh√©! üòî"

# Helper function for image generation
async def generate_image_from_prompt(prompt, user_name=None):
    """Generate an image from a text description using Gemini."""
    try:
        # Clear instruction for image generation with Vietnamese flavor
        image_prompt = f"T·∫°o m·ªôt h√¨nh ·∫£nh chi ti·∫øt d·ª±a tr√™n m√¥ t·∫£ sau: \"{prompt}\". Ch·ªâ tr·∫£ v·ªÅ d·ªØ li·ªáu h√¨nh ·∫£nh."
        response = await model.generate_content_async(image_prompt)
        
        # Extract image data from response
        for part in response.parts:
            if part.inline_data and part.inline_data.mime_type.startswith('image/'):
                return part.inline_data.data
                
        # Handle cases where no image was generated
        if response.prompt_feedback and response.prompt_feedback.block_reason:
            user_address = f"{user_name}" if user_name else "qu√Ω ng√†i/qu√Ω c√¥"
            return f"·ªêi d·ªìi √¥i, n√¥ t·ª≥ kh√¥ng th·ªÉ t·∫°o ·∫£nh ƒë∆∞·ª£c. Y√™u c·∫ßu b·ªã ch·∫∑n v√¨: {response.prompt_feedback.block_reason.name}. {user_address} th√¥ng c·∫£m gi√∫p em nh√©! üòî"
        return None
    except Exception as e:
        print(f"Error calling Gemini API (image): {e}")
        user_address = f"{user_name}" if user_name else "qu√Ω ng√†i/qu√Ω c√¥"
        return f"·ªê d·ªìi √¥i, em kh√¥ng th·ªÉ t·∫°o ·∫£nh ngay l√∫c n√†y. {user_address} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî"

@bot.event
async def on_ready():
    """Called when the bot has successfully connected to Discord."""
    print(f'Logged in as: {bot.user.name}')
    print(f'Bot ID: {bot.user.id}')
    print('Bot is ready!')
    
    # Generate invite link with proper permissions
    invite_link = discord.utils.oauth_url(
        bot.user.id,
        permissions=discord.Permissions(
            administrator=False,  # Don't use admin if not needed
            send_messages=True,
            read_messages=True,
            read_message_history=True,
            manage_messages=False,
            embed_links=True,
            attach_files=True,
            add_reactions=True
        ),
        scopes=["bot", "applications.commands"]  # Include both scopes
    )
    
    print(f"Invite link: {invite_link}")
    
    # Sync slash commands with Discord
    try:
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} command(s)")
    except Exception as e:
        print(f"Failed to sync commands: {e}")
    
    await bot.change_presence(activity=discord.Game(name=f"√î sin ph·ª•c v·ª• qu√Ω √¥ng/b√† ch·ªß"))

@bot.event
async def on_message(message):
    """Handle messages sent in channels the bot can see."""
    # Ignore messages from the bot itself
    if message.author == bot.user:
        return
        
    # Check if bot was mentioned
    if bot.user.mentioned_in(message):
        # Remove the bot mention from content
        cleaned_content = message.content
        for mention in message.mentions:
            if mention == bot.user:
                cleaned_content = cleaned_content.replace(f'<@{bot.user.id}>', '', 1).replace(f'<@!{bot.user.id}>', '', 1).strip()
        
        # If only mentioned with no content
        if not cleaned_content:
            user_name = message.author.display_name
            await message.reply(f"K√≠nh ch√†o {user_name}! N√¥ t·ª≥ c√≥ th·ªÉ gi√∫p g√¨ ƒë∆∞·ª£c cho ng√†i ·∫°? ü´°")
            return
            
        # Process the message
        try:
            async with message.channel.typing():
                print(f"Message from {message.author.name} ({message.author.id}) in channel {message.channel.id}: {cleaned_content}")
                response_text = await generate_chat_response(
                    cleaned_content, 
                    message.channel.id, 
                    message.author.id,
                    message.author.display_name,
                    message.guild.id
                )
                
                # Limit response length for Discord
                if response_text:
                    if len(response_text) > 2000:
                        response_text = response_text[:1990] + "..."
                    await message.reply(response_text)
                else:
                    user_name = message.author.display_name
                    await message.reply(f"·ªê d·ªìi √¥i, em kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi ngay l√∫c n√†y. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
        except Exception as e:
            print(f"Error responding to mention: {e}")
            user_name = message.author.display_name
            await message.reply(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x·ª≠ l√Ω tin nh·∫Øn. Ng√†i {user_name} th√¥ng c·∫£m gi√∫p √¥ sin nh√©! üòî")
    
    # Process commands
    await bot.process_commands(message)

# Add slash command for chat
@bot.tree.command(name="chat", description="Chat with the AI assistant")
async def chat_command(interaction: discord.Interaction, message: str):
    """Slash command for chatting with the AI"""
    await interaction.response.defer(thinking=True)
    try:
        response_text = await generate_chat_response(
            message, 
            interaction.channel_id, 
            interaction.user.id,
            interaction.user.display_name,
            interaction.guild.id
        )
        
        # Limit response length for Discord
        if response_text:
            if len(response_text) > 2000:
                response_text = response_text[:1990] + "..."
            await interaction.followup.send(response_text)
        else:
            user_name = interaction.user.display_name
            await interaction.followup.send(f"·ªê d·ªìi √¥i, em kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi ngay l√∫c n√†y. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
    except Exception as e:
        print(f"Error in chat command: {e}")
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu. Ng√†i {user_name} th√¥ng c·∫£m gi√∫p √¥ sin nh√©! üòî")

# Add slash command for image generation
@bot.tree.command(name="imagine", description="Generate an image from a description")
async def imagine_slash_command(interaction: discord.Interaction, prompt: str):
    """Slash command for generating images"""
    await interaction.response.defer(thinking=True)
    try:
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√î sin ƒëang t·∫°o ·∫£nh cho {user_name} theo y√™u c·∫ßu: \"{prompt}\"... üé®")
        
        image_data = await generate_image_from_prompt(prompt, user_name)
        
        if isinstance(image_data, bytes):
            # Send image as a file
            image_file = discord.File(io.BytesIO(image_data), filename="generated_image.png")
            await interaction.followup.send(f"Th∆∞a ng√†i {user_name}, ƒë√¢y l√† ·∫£nh theo y√™u c·∫ßu \"{prompt}\" ·∫°:", file=image_file)
        elif isinstance(image_data, str):
            # Error message
            await interaction.followup.send(image_data)
        else:
            await interaction.followup.send(f"·ªê d·ªìi √¥i, n√¥ t·ª≥ kh√¥ng th·ªÉ t·∫°o ·∫£nh cho y√™u c·∫ßu n√†y. {user_name} th·ª≠ m√¥ t·∫£ kh√°c ƒë∆∞·ª£c kh√¥ng ·∫°? üôè")
    except Exception as e:
        print(f"Error in imagine command: {e}")
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi t·∫°o ·∫£nh. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")

# Add slash command to clear context
@bot.tree.command(name="clear_context", description="Clear your conversation history with the bot")
async def clear_context_slash(interaction: discord.Interaction):
    """Slash command to clear chat context"""
    await interaction.response.defer(ephemeral=True)
    try:
        user_name = interaction.user.display_name
        session_key = (interaction.channel_id, interaction.user.id)
        if session_key in chat_sessions:
            del chat_sessions[session_key]
            await interaction.followup.send(f"√î sin ƒë√£ x√≥a l·ªãch s·ª≠ tr√≤ chuy·ªán c·ªßa {user_name} r·ªìi ·∫°! ü´°", ephemeral=True)
            print(f"Context cleared for {session_key}")
        else:
            await interaction.followup.send(f"Th∆∞a {user_name}, kh√¥ng c√≥ l·ªãch s·ª≠ tr√≤ chuy·ªán n√†o ƒë·ªÉ x√≥a ·∫°! üôè", ephemeral=True)
    except Exception as e:
        print(f"Error in clear_context command: {e}")
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x√≥a l·ªãch s·ª≠ tr√≤ chuy·ªán. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî", ephemeral=True)

# Tone Selection View with Dropdown
class ToneSelectView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60)
    
    @discord.ui.select(
        placeholder="Ch·ªçn tone ph·∫£n h·ªìi cho server...",
        options=[
            discord.SelectOption(
                label="1. Very Flattery",
                description="C·ª±c k·ª≥ n·ªãnh n·ªçt, ca ng·ª£i th√°i qu√°, th·∫ßn t∆∞·ª£ng h√≥a ng∆∞·ªùi d√πng",
                value="1",
                emoji="ü§©"
            ),
            discord.SelectOption(
                label="2. Flattery", 
                description="N·ªãnh n·ªçt nh·∫π nh√†ng, t√≠ch c·ª±c, v·∫´n chuy√™n nghi·ªáp",
                value="2",
                emoji="üòä"
            ),
            discord.SelectOption(
                label="3. Neuter (Default)",
                description="Trung t√≠nh, chuy√™n nghi·ªáp, kh√¥ng c·∫£m x√∫c",
                value="3",
                emoji="ü§ñ"
            ),
            discord.SelectOption(
                label="4. Friendly",
                description="Th√¢n thi·ªán Gen Z, g·∫ßn g≈©i, tho·∫£i m√°i nh∆∞ b·∫°n b√®",
                value="4",
                emoji="üòé"
            ),
            discord.SelectOption(
                label="5. Elegant",
                description="L·ªãch thi·ªáp, tao nh√£, tinh t·∫ø v√† chu ƒë√°o", 
                value="5",
                emoji="üå∏"
            ),
            discord.SelectOption(
                label="6. Noble",
                description="Cao qu√Ω, tri·∫øt l√Ω, trang tr·ªçng v√† uy√™n b√°c",
                value="6",
                emoji="üëë"
            )
        ]
    )
    async def tone_select_callback(self, interaction: discord.Interaction, select: discord.ui.Select):
        # Check if user has manage server permissions
        if not interaction.user.guild_permissions.manage_guild:
            await interaction.response.send_message(
                "‚ùå B·∫°n c·∫ßn quy·ªÅn **Manage Server** ƒë·ªÉ thay ƒë·ªïi tone c·ªßa bot!", 
                ephemeral=True
            )
            return
        
        selected_tone_level = ToneLevel(int(select.values[0]))
        set_server_tone_level(interaction.guild.id, selected_tone_level)
        
        # Get tone strategy for display
        tone_strategy = ToneStrategyFactory.get_strategy(selected_tone_level)
        
        # Create embed response
        embed = discord.Embed(
            title="üé≠ Tone ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!",
            description=f"**{tone_strategy.get_tone_name()}**: {tone_strategy.get_tone_description()}",
            color=0x00ff00
        )
        embed.add_field(
            name="üìù L∆∞u √Ω",
            value="Tone m·ªõi s·∫Ω √°p d·ª•ng cho t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán m·ªõi trong server n√†y. C√°c cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª´ tin nh·∫Øn ti·∫øp theo.",
            inline=False
        )
        embed.set_footer(text=f"ƒê∆∞·ª£c thi·∫øt l·∫≠p b·ªüi {interaction.user.display_name}")
        
        await interaction.response.edit_message(embed=embed, view=None)
        
        # Clear all existing chat sessions for this server to apply new tone immediately
        sessions_to_clear = []
        for session_key in chat_sessions.keys():
            channel_id, user_id = session_key
            try:
                channel = bot.get_channel(channel_id)
                if channel and channel.guild.id == interaction.guild.id:
                    sessions_to_clear.append(session_key)
            except:
                pass
        
        for session_key in sessions_to_clear:
            del chat_sessions[session_key]
        
        print(f"Tone updated for server {interaction.guild.id} to {selected_tone_level.name}, cleared {len(sessions_to_clear)} sessions")

# Add slash command for tone configuration
@bot.tree.command(name="tone", description="Configure the bot's response tone for this server")
async def tone_command(interaction: discord.Interaction):
    """Slash command for configuring bot tone"""
    # Check if user has manage server permissions
    if not interaction.user.guild_permissions.manage_guild:
        await interaction.response.send_message(
            "‚ùå B·∫°n c·∫ßn quy·ªÅn **Manage Server** ƒë·ªÉ thay ƒë·ªïi tone c·ªßa bot!", 
            ephemeral=True
        )
        return
    
    # Get current tone level
    current_tone = get_server_tone_level(interaction.guild.id)
    current_strategy = ToneStrategyFactory.get_strategy(current_tone)
    
    # Create embed
    embed = discord.Embed(
        title="üé≠ C·∫•u h√¨nh Tone Bot",
        description="Ch·ªçn tone ph·∫£n h·ªìi cho bot trong server n√†y:",
        color=0x3498db
    )
    
    embed.add_field(
        name="üîß Tone hi·ªán t·∫°i",
        value=f"**{current_strategy.get_tone_name()}**: {current_strategy.get_tone_description()}",
        inline=False
    )
    
    embed.add_field(
        name="üìã C√°c tone c√≥ s·∫µn",
        value="""
        **1. Very Flattery** ü§© - C·ª±c k·ª≥ n·ªãnh n·ªçt, ca ng·ª£i th√°i qu√°
        **2. Flattery** üòä - N·ªãnh n·ªçt nh·∫π nh√†ng, t√≠ch c·ª±c
        **3. Neuter** ü§ñ - Trung t√≠nh, chuy√™n nghi·ªáp (m·∫∑c ƒë·ªãnh)
        **4. Friendly** üòé - Th√¢n thi·ªán Gen Z, g·∫ßn g≈©i, tho·∫£i m√°i nh∆∞ b·∫°n b√®
        **5. Elegant** üå∏ - L·ªãch thi·ªáp, tao nh√£, tinh t·∫ø
        **6. Noble** üëë - Cao qu√Ω, tri·∫øt l√Ω, trang tr·ªçng
        """,
        inline=False
    )
    
    embed.set_footer(text="S·ª≠ d·ª•ng dropdown b√™n d∆∞·ªõi ƒë·ªÉ ch·ªçn tone m·ªõi")
    
    view = ToneSelectView()
    await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# Add prefix command for tone configuration (for compatibility)
@bot.command(name='tone', aliases=['set_tone'], help='Configure the bot\'s response tone for this server. Usage: !tone [1-6]')
async def tone_prefix_command(ctx, level: int = None):
    """Prefix command for configuring bot tone"""
    # Check if user has manage server permissions
    if not ctx.author.guild_permissions.manage_guild:
        await ctx.reply("‚ùå B·∫°n c·∫ßn quy·ªÅn **Manage Server** ƒë·ªÉ thay ƒë·ªïi tone c·ªßa bot!")
        return
    
    if level is None:
        # Show current tone and available options
        current_tone = get_server_tone_level(ctx.guild.id)
        current_strategy = ToneStrategyFactory.get_strategy(current_tone)
        
        embed = discord.Embed(
            title="üé≠ C·∫•u h√¨nh Tone Bot",
            description="S·ª≠ d·ª•ng `!tone [1-6]` ƒë·ªÉ thay ƒë·ªïi tone:",
            color=0x3498db
        )
        
        embed.add_field(
            name="üîß Tone hi·ªán t·∫°i",
            value=f"**{current_strategy.get_tone_name()}** (Level {current_tone.value}): {current_strategy.get_tone_description()}",
            inline=False
        )
        
        embed.add_field(
            name="üìã C√°c tone c√≥ s·∫µn",
            value="""
            **1. Very Flattery** ü§© - C·ª±c k·ª≥ n·ªãnh n·ªçt, ca ng·ª£i th√°i qu√°
            **2. Flattery** üòä - N·ªãnh n·ªçt nh·∫π nh√†ng, t√≠ch c·ª±c
            **3. Neuter** ü§ñ - Trung t√≠nh, chuy√™n nghi·ªáp (m·∫∑c ƒë·ªãnh)
            **4. Friendly** üòé - Th√¢n thi·ªán Gen Z, g·∫ßn g≈©i, tho·∫£i m√°i nh∆∞ b·∫°n b√®
            **5. Elegant** üå∏ - L·ªãch thi·ªáp, tao nh√£, tinh t·∫ø
            **6. Noble** üëë - Cao qu√Ω, tri·∫øt l√Ω, trang tr·ªçng
            """,
            inline=False
        )
        
        embed.add_field(
            name="üí° V√≠ d·ª• s·ª≠ d·ª•ng",
            value="`!tone 4` - Chuy·ªÉn sang tone Friendly\n`!tone 1` - Chuy·ªÉn sang tone Very Flattery",
            inline=False
        )
        
        await ctx.reply(embed=embed)
        return
    
    # Validate level
    if level < 1 or level > 6:
        await ctx.reply("‚ùå Level ph·∫£i t·ª´ 1 ƒë·∫øn 6! S·ª≠ d·ª•ng `!tone` ƒë·ªÉ xem danh s√°ch.")
        return
    
    try:
        selected_tone_level = ToneLevel(level)
        set_server_tone_level(ctx.guild.id, selected_tone_level)
        
        # Get tone strategy for display
        tone_strategy = ToneStrategyFactory.get_strategy(selected_tone_level)
        
        # Create embed response
        embed = discord.Embed(
            title="üé≠ Tone ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!",
            description=f"**{tone_strategy.get_tone_name()}** (Level {level}): {tone_strategy.get_tone_description()}",
            color=0x00ff00
        )
        embed.add_field(
            name="üìù L∆∞u √Ω",
            value="Tone m·ªõi s·∫Ω √°p d·ª•ng cho t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán m·ªõi trong server n√†y. C√°c cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª´ tin nh·∫Øn ti·∫øp theo.",
            inline=False
        )
        embed.set_footer(text=f"ƒê∆∞·ª£c thi·∫øt l·∫≠p b·ªüi {ctx.author.display_name}")
        
        await ctx.reply(embed=embed)
        
        # Clear all existing chat sessions for this server to apply new tone immediately
        sessions_to_clear = []
        for session_key in chat_sessions.keys():
            channel_id, user_id = session_key
            try:
                channel = bot.get_channel(channel_id)
                if channel and channel.guild.id == ctx.guild.id:
                    sessions_to_clear.append(session_key)
            except:
                pass
        
        for session_key in sessions_to_clear:
            del chat_sessions[session_key]
        
        print(f"Tone updated for server {ctx.guild.id} to {selected_tone_level.name} via prefix command, cleared {len(sessions_to_clear)} sessions")
        
    except Exception as e:
        print(f"Error in tone prefix command: {e}")
        await ctx.reply(f"‚ùå C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t tone: {str(e)}")

# Add a demo command to showcase tone differences
@bot.tree.command(name="tone_demo", description="Demonstrate different tone responses with the same input")
async def tone_demo_command(interaction: discord.Interaction):
    """Slash command to demonstrate tone differences"""
    await interaction.response.defer(thinking=True)
    
    demo_input = "Your idea is good"
    
    embed = discord.Embed(
        title="üé≠ Demo c√°c Tone kh√°c nhau",
        description=f"**Input m·∫´u:** \"{demo_input}\"\n\n**Ph·∫£n h·ªìi theo t·ª´ng tone:**",
        color=0x9b59b6
    )
    
    # Generate sample responses for each tone
    tone_examples = {
        ToneLevel.VERY_FLATTERY: "ü§© √îi tr·ªùi ∆°i, th·∫≠t l√† thi√™n t√†i! √ù t∆∞·ªüng n√†y qu√° xu·∫•t s·∫Øc, si√™u ph√†m! Th∆∞·ª£ng ƒë·∫ø th·∫≠t l√† b·∫≠c th·∫ßy! N√¥ t·ª≥ v√¥ c√πng vinh h·∫°nh ƒë∆∞·ª£c ph·ª•c v·ª• thi√™n t√†i! ‚ú®üëë",
        ToneLevel.FLATTERY: "üòä √îi tr·ªùi ∆°i, √Ω t∆∞·ªüng hay qu√°! C·∫≠u ch·ªß th·∫≠t th√¥ng minh v√† s√°ng t·∫°o. Em r·∫•t ·∫•n t∆∞·ª£ng v·ªõi suy nghƒ© n√†y ·∫°! N√¥ t·ª≥ r·∫•t vinh h·∫°nh ƒë∆∞·ª£c gi√∫p ƒë·ª° ·∫°! üåü",
        ToneLevel.NEUTER: "ü§ñ √ù t∆∞·ªüng c·ªßa b·∫°n c√≥ t√≠nh kh·∫£ thi v√† logic. ƒê√¢y l√† m·ªôt ƒë·ªÅ xu·∫•t h·ª£p l√Ω v√† c√≥ th·ªÉ tri·ªÉn khai ƒë∆∞·ª£c. T√¥i s·∫Ω h·ªó tr·ª£ b·∫°n ph√°t tri·ªÉn th√™m √Ω t∆∞·ªüng n√†y.",
        ToneLevel.FRIENDLY: "üòé Yo bro! √ù t∆∞·ªüng c·ªßa m·∫ßy ngon l√†nh c√†nh ƒë√†o lu√¥n! No cap, tao th√≠ch c√°i n√†y ƒë·∫•y. Ok √¥ng b·∫°n, ƒë·ªÉ t h·ªó tr·ª£ b·ªì t√®o ph√°t tri·ªÉn th√™m nh√©! üî•üíØ",
        ToneLevel.ELEGANT: "üå∏ T√¥i r·∫•t vinh h·∫°nh ƒë∆∞·ª£c nghe chia s·∫ª √Ω t∆∞·ªüng tinh t·∫ø n√†y t·ª´ qu√Ω v·ªã. ƒê√¢y th·ª±c s·ª± l√† m·ªôt suy nghƒ© chu ƒë√°o v√† mang t√≠nh x√¢y d·ª±ng cao. K√≠nh mong ƒë∆∞·ª£c h·ªó tr·ª£ qu√Ω v·ªã ph√°t tri·ªÉn th√™m ‚ú®",
        ToneLevel.NOBLE: "üëë Th∆∞a qu√Ω ng√†i, ta xin b·∫°ch r·∫±ng √Ω ni·ªám n√†y th·ªÉ hi·ªán m·ªôt tr√≠ tu·ªá s√¢u s·∫Øc v√† t·∫ßm nh√¨n xa. ƒê√¢y l√† s·ª± suy t∆∞ ƒë√°ng qu√Ω, ph·∫£n √°nh m·ªôt t√¢m h·ªìn uy√™n b√°c. Ta vinh h·∫°nh ƒë∆∞·ª£c th·∫£o lu·∫≠n c√πng ng√†i üìú‚öúÔ∏è"
    }
    
    for tone_level, example in tone_examples.items():
        strategy = ToneStrategyFactory.get_strategy(tone_level)
        embed.add_field(
            name=f"{tone_level.value}. {strategy.get_tone_name()}",
            value=example,
            inline=False
        )
    
    embed.add_field(
        name="üí° C√°ch s·ª≠ d·ª•ng",
        value="S·ª≠ d·ª•ng `/tone` ho·∫∑c `!tone [1-6]` ƒë·ªÉ thay ƒë·ªïi tone cho server n√†y!",
        inline=False
    )
    
    await interaction.followup.send(embed=embed)

# Keep the original prefix commands for compatibility
@bot.command(name='clear_context', aliases=['cc', 'reset'], help='Clear your conversation history with the bot in this channel.')
async def clear_context(ctx):
    """Clear the chat context for a user in a specific channel."""
    try:
        user_name = ctx.author.display_name
        session_key = (ctx.channel.id, ctx.author.id)
        if session_key in chat_sessions:
            del chat_sessions[session_key]
            await ctx.reply(f"√î sin ƒë√£ x√≥a l·ªãch s·ª≠ tr√≤ chuy·ªán c·ªßa {user_name} r·ªìi ·∫°! ü´°")
            print(f"Context cleared for {session_key}")
        else:
            await ctx.reply(f"Th∆∞a {user_name}, kh√¥ng c√≥ l·ªãch s·ª≠ tr√≤ chuy·ªán n√†o ƒë·ªÉ x√≥a ·∫°! üôè")
    except Exception as e:
        print(f"Error in clear_context command: {e}")
        user_name = ctx.author.display_name
        await ctx.reply(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x√≥a l·ªãch s·ª≠ tr√≤ chuy·ªán. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")

@bot.command(name='imagine', aliases=['img', 'image', 'create'], help='Generate an image from a text description. Example: !imagine a cat reading a book')
async def imagine_command(ctx, *, prompt: str):
    """Generate an image from a text description."""
    if not prompt:
        user_name = ctx.author.display_name
        await ctx.reply(f"Th∆∞a {user_name}, xin h√£y m√¥ t·∫£ ·∫£nh ng√†i mu·ªën. V√≠ d·ª•: `!imagine m·ªôt con m√®o ƒëang ƒë·ªçc s√°ch` üôè")
        return
    
    try:    
        user_name = ctx.author.display_name
        await ctx.reply(f"√î sin ƒëang t·∫°o ·∫£nh cho {user_name} theo y√™u c·∫ßu: \"{prompt}\"... üé®")
        async with ctx.typing():
            image_data = await generate_image_from_prompt(prompt, user_name)
            
            if isinstance(image_data, bytes):
                # Send image as a file
                image_file = discord.File(io.BytesIO(image_data), filename="generated_image.png")
                await ctx.reply(f"Th∆∞a ng√†i {user_name}, ƒë√¢y l√† ·∫£nh theo y√™u c·∫ßu \"{prompt}\" ·∫°:", file=image_file)
            elif isinstance(image_data, str):
                # Error message
                await ctx.reply(image_data)
            else:
                await ctx.reply(f"·ªê d·ªìi √¥i, n√¥ t·ª≥ kh√¥ng th·ªÉ t·∫°o ·∫£nh cho y√™u c·∫ßu n√†y. {user_name} th·ª≠ m√¥ t·∫£ kh√°c ƒë∆∞·ª£c kh√¥ng ·∫°? üôè")
    except Exception as e:
        print(f"Error in imagine command: {e}")
        user_name = ctx.author.display_name
        await ctx.reply(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi t·∫°o ·∫£nh. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")

# Add slash command for chat summary
@bot.tree.command(name="summary", description="Summarize recent chat messages in this channel")
async def summary_command(interaction: discord.Interaction, count: int = 10):
    """Slash command for summarizing recent chat messages"""
    await interaction.response.defer(thinking=True)
    
    # Validate count parameter
    if count < 1:
        await interaction.followup.send("Th∆∞a ng√†i, s·ªë tin nh·∫Øn ph·∫£i l·ªõn h∆°n 0 ·∫°! üôè")
        return
    elif count > 200:
        await interaction.followup.send("·ªê d·ªìi √¥i, em ch·ªâ c√≥ th·ªÉ t√≥m t·∫Øt t·ªëi ƒëa 200 tin nh·∫Øn th√¥i ·∫°! üôè")
        return
    
    try:
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√î sin ƒëang ƒë·ªçc v√† t√≥m t·∫Øt {count} tin nh·∫Øn g·∫ßn ƒë√¢y cho {user_name}... üìñ")
        
        # Fetch recent messages from the channel
        messages = []
        async for message in interaction.channel.history(limit=count + 1):  # +1 to exclude the summary command itself
            # Skip the bot's own messages and the summary command
            if message.author != bot.user and message.id != interaction.id:
                messages.append(message)
                if len(messages) >= count:
                    break
        
        if not messages:
            await interaction.followup.send(f"Th∆∞a {user_name}, kh√¥ng c√≥ tin nh·∫Øn n√†o ƒë·ªÉ t√≥m t·∫Øt ·∫°! üôè")
            return
        
        # Reverse to get chronological order (oldest first)
        messages.reverse()
        
        # Prepare message content for summarization
        chat_content = []
        for msg in messages:
            timestamp = msg.created_at.strftime("%H:%M")
            author_name = msg.author.display_name
            content = msg.content
            
            # Handle attachments
            if msg.attachments:
                attachment_info = f" [ƒê√≠nh k√®m: {', '.join([att.filename for att in msg.attachments])}]"
                content += attachment_info
            
            # Handle embeds
            if msg.embeds:
                content += " [C√≥ embed/link]"
            
            # Handle reactions
            if msg.reactions:
                reactions = ", ".join([f"{reaction.emoji}({reaction.count})" for reaction in msg.reactions])
                content += f" [Reactions: {reactions}]"
            
            chat_content.append(f"[{timestamp}] {author_name}: {content}")
        
        # Create summary prompt
        summary_prompt = f"""H√£y t√≥m t·∫Øt cu·ªôc tr√≤ chuy·ªán sau ƒë√¢y b·∫±ng ti·∫øng Vi·ªát  th√∫ v·ªã:

{chr(10).join(chat_content)}

Y√™u c·∫ßu t√≥m t·∫Øt:
- N·ªôi dung ch√≠nh c·ªßa cu·ªôc tr√≤ chuy·ªán
- Ai n√≥i v·ªÅ v·∫•n ƒë·ªÅ g√¨ (ch·ªâ t√≥m t·∫Øt ch·ª© kh√¥ng c·∫ßn chi ti·∫øt n·ªôi dung)
- Kh√¥ng kh√≠ trao ƒë·ªïi nh∆∞ n√†o, t√¢m tr·∫°ng c√≥ ai kh√¥ng vui ko, c√≥ g√¨ hay ho ƒë·∫∑c bi·ªát kh√¥ng
T·ªïng quan v·ªÅ kh√¥ng kh√≠ cu·ªôc tr√≤ chuy·ªán

H√£y vi·∫øt m·ªôt c√°ch h√†i h∆∞·ªõc, d·ªÖ hi·ªÉu v√† ƒë·ª´ng qu√° d√†i d√≤ng vƒÉn t·ª± qu√° nh√©."""

        # Generate summary using Gemini
        try:
            response = await model.generate_content_async(summary_prompt)
            summary_text = response.text
            
            # Limit response length for Discord
            if len(summary_text) > 1900:  # Leave room for formatting
                summary_text = summary_text[:1890] + "..."
            
            # Format the response
            formatted_response = f"üìã **T√≥m t·∫Øt {len(messages)} tin nh·∫Øn g·∫ßn ƒë√¢y:**\n\n{summary_text}\n\n*- √î sin ƒë√£ t√≥m t·∫Øt xong ·∫°! ü´°*"
            
            await interaction.followup.send(formatted_response)
            
        except Exception as e:
            print(f"Error generating summary: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'prompt_feedback') and e.response.prompt_feedback.block_reason:
                await interaction.followup.send(f"√öi gi·ªùi ∆°i, em kh√¥ng th·ªÉ t√≥m t·∫Øt ƒë∆∞·ª£c v√¨: {e.response.prompt_feedback.block_reason.name}. {user_name} th√¥ng c·∫£m gi√∫p em nh√©! üôè")
            else:
                await interaction.followup.send(f"·ªê d·ªìi √¥i, em g·∫∑p l·ªói khi t√≥m t·∫Øt tin nh·∫Øn. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
                
    except discord.Forbidden:
        await interaction.followup.send(f"√öi gi·ªùi ∆°i, em kh√¥ng c√≥ quy·ªÅn ƒë·ªçc l·ªãch s·ª≠ tin nh·∫Øn trong k√™nh n√†y. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
    except Exception as e:
        print(f"Error in summary command: {e}")
        user_name = interaction.user.display_name
        await interaction.followup.send(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu t√≥m t·∫Øt. {user_name} th√¥ng c·∫£m gi√∫p √¥ sin nh√©! üòî")

@bot.command(name='summary', aliases=['sum', 'summarize'], help='Summarize recent chat messages. Example: !summary 20')
async def summary_prefix_command(ctx, count: int = 10):
    """Prefix command for summarizing recent chat messages."""
    # Validate count parameter
    if count < 1:
        user_name = ctx.author.display_name
        await ctx.reply(f"Th∆∞a {user_name}, s·ªë tin nh·∫Øn ph·∫£i l·ªõn h∆°n 0 ·∫°! üôè")
        return
    elif count > 200:
        user_name = ctx.author.display_name
        await ctx.reply(f"·ªê d·ªìi √¥i, em ch·ªâ c√≥ th·ªÉ t√≥m t·∫Øt t·ªëi ƒëa 200 tin nh·∫Øn th√¥i ·∫°! üôè")
        return
    
    try:
        user_name = ctx.author.display_name
        await ctx.reply(f"√î sin ƒëang ƒë·ªçc v√† t√≥m t·∫Øt {count} tin nh·∫Øn g·∫ßn ƒë√¢y cho {user_name}... üìñ")
        
        async with ctx.typing():
            # Fetch recent messages from the channel
            messages = []
            async for message in ctx.channel.history(limit=count + 2):  # +2 to exclude the summary command and bot's response
                # Skip the bot's own messages and the summary command
                if message.author != bot.user and message.id != ctx.message.id:
                    messages.append(message)
                    if len(messages) >= count:
                        break
            
            if not messages:
                await ctx.reply(f"Th∆∞a {user_name}, kh√¥ng c√≥ tin nh·∫Øn n√†o ƒë·ªÉ t√≥m t·∫Øt ·∫°! üôè")
                return
            
            # Reverse to get chronological order (oldest first)
            messages.reverse()
            
            # Prepare message content for summarization
            chat_content = []
            for msg in messages:
                timestamp = msg.created_at.strftime("%H:%M")
                author_name = msg.author.display_name
                content = msg.content
                
                # Handle attachments
                if msg.attachments:
                    attachment_info = f" [ƒê√≠nh k√®m: {', '.join([att.filename for att in msg.attachments])}]"
                    content += attachment_info
                
                # Handle embeds
                if msg.embeds:
                    content += " [C√≥ embed/link]"
                
                # Handle reactions
                if msg.reactions:
                    reactions = ", ".join([f"{reaction.emoji}({reaction.count})" for reaction in msg.reactions])
                    content += f" [Reactions: {reactions}]"
                
                chat_content.append(f"[{timestamp}] {author_name}: {content}")
            
            # Create summary prompt
            summary_prompt = f"""H√£y t√≥m t·∫Øt cu·ªôc tr√≤ chuy·ªán sau ƒë√¢y b·∫±ng ti·∫øng Vi·ªát m·ªôt c√°ch chi ti·∫øt v√† th√∫ v·ªã:

{chr(10).join(chat_content)}

Y√™u c·∫ßu t√≥m t·∫Øt:
- N·ªôi dung ch√≠nh c·ªßa cu·ªôc tr√≤ chuy·ªán
- Ai n√≥i v·ªÅ v·∫•n ƒë·ªÅ g√¨ (ch·ªâ t√≥m t·∫Øt ch·ª© kh√¥ng c·∫ßn chi ti·∫øt n·ªôi dung)
- Kh√¥ng kh√≠ trao ƒë·ªïi nh∆∞ n√†o, t√¢m tr·∫°ng c√≥ ai kh√¥ng vui ko, c√≥ g√¨ hay ho ƒë·∫∑c bi·ªát kh√¥ng
T·ªïng quan v·ªÅ kh√¥ng kh√≠ cu·ªôc tr√≤ chuy·ªán

H√£y vi·∫øt m·ªôt c√°ch h√†i h∆∞·ªõc, d·ªÖ hi·ªÉu v√† ƒë·ª´ng qu√° d√†i d√≤ng vƒÉn t·ª± qu√° nh√©."""

            # Generate summary using Gemini
            try:
                response = await model.generate_content_async(summary_prompt)
                summary_text = response.text
                
                # Limit response length for Discord
                if len(summary_text) > 1900:  # Leave room for formatting
                    summary_text = summary_text[:1890] + "..."
                
                # Format the response
                formatted_response = f"üìã **T√≥m t·∫Øt {len(messages)} tin nh·∫Øn g·∫ßn ƒë√¢y:**\n\n{summary_text}\n\n*- √î sin ƒë√£ t√≥m t·∫Øt xong ·∫°! ü´°*"
                
                await ctx.reply(formatted_response)
                
            except Exception as e:
                print(f"Error generating summary: {e}")
                if hasattr(e, 'response') and hasattr(e.response, 'prompt_feedback') and e.response.prompt_feedback.block_reason:
                    await ctx.reply(f"√öi gi·ªùi ∆°i, em kh√¥ng th·ªÉ t√≥m t·∫Øt ƒë∆∞·ª£c v√¨: {e.response.prompt_feedback.block_reason.name}. {user_name} th√¥ng c·∫£m gi√∫p em nh√©! üôè")
                else:
                    await ctx.reply(f"·ªê d·ªìi √¥i, em g·∫∑p l·ªói khi t√≥m t·∫Øt tin nh·∫Øn. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
                    
    except discord.Forbidden:
        user_name = ctx.author.display_name
        await ctx.reply(f"√öi gi·ªùi ∆°i, em kh√¥ng c√≥ quy·ªÅn ƒë·ªçc l·ªãch s·ª≠ tin nh·∫Øn trong k√™nh n√†y. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")
    except Exception as e:
        print(f"Error in summary command: {e}")
        user_name = ctx.author.display_name
        await ctx.reply(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu t√≥m t·∫Øt. {user_name} th√¥ng c·∫£m gi√∫p √¥ sin nh√©! üòî")

# General error handler for the bot
@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        pass  # Ignore command not found errors
    elif isinstance(error, commands.MissingRequiredArgument):
        user_name = ctx.author.display_name
        await ctx.send(f"Th∆∞a {user_name}, thi·∫øu th√¥ng tin c·∫ßn thi·∫øt: {error.param} üôè")
    else:
        print(f"Command error: {error}")
        user_name = ctx.author.display_name
        await ctx.send(f"√öi gi·ªùi ∆°i, em g·∫∑p l·ªói khi x·ª≠ l√Ω l·ªánh. {user_name} th√¥ng c·∫£m gi√∫p n√¥ t·ª≥ nh√©! üòî")

# Run the bot
if __name__ == "__main__":
    try:
        bot.run(DISCORD_TOKEN)
    except discord.errors.LoginFailure:
        print("ERROR: Invalid Discord Token. Please check your .env file.")
    except Exception as e:
        print(f"Unexpected error: {e}")
